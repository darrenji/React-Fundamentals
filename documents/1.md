<br>

# ES6和babel #

<br>

TC-39这个委员会专门制定EcmaScript的标准。ES6指的是EcmaScript 2015(同理，ES7指的是EcmaScript2016)， babel与之对应的部分，通过 **npm install --save-dev babel-preset-es2015**.然后需要在`.bablerc`文件中配置 **babel-preset-es2015**.

<br>

# let和const关键字 #

<br>

Javascript的作用域是分层的，子作用域可以获取到父作用域的变量。作用域与函数息息相关。比如：

	//这里是全局的作用域
	var firstFunction = functioin(){
		//这里是firstFunction的作用域
		var secondFunction = function(){
			//这里是secondFunction的作用域
		}
	}

<br>

let的存在让这一切发生了改变，let所在的语句块就是一个作用域。

	function doThing(){
		var num = 1;
		if(num >= 0){
			//let所在的语句块，即{}之间形成了作用域
			let secondNum = 2;
			console.log(num); //1
			console.log(secondNum); //2
		}

		console.log(num); //1
		console.log(secondNum); //Uncaught ReferenceError: secondNum is not defined
	}

	doThing();

<br>

let有的const也有，两者的区别是：声明为cosnt类型的变量不能重新赋予新的引用。

	const user = {
		name: 'a',
		age: 25
	};

	user.name = 'b';

以上是不会报错的。需要说明的是：const类型变量不能重新赋予新的引用，不等于说该变量是不可变的。

<br>

以下的写法是错误的：

	const user = {
		name: 'a',
		age: 25
	};

	user = {
		name: 'b',
		age:25
	};

因为，相当于给const类型的变量user赋上了新的引用。会报一个"user is already defined"的错。

<br>

# ES6的导入导出 #

<br>

在ES6中导入导出用到的关键字是export和import.

	//math.js
	export function add(x,y){
		return x + y;
	}

	export function multiply(x, y){
		return x * y;
	}

	export function divide(x, y){
		return x / y;
	}

	//main.js
	import {add, multiply} from './math'
	add(1,2);
	multiply(3,4);

以上，export的有3个，我们import了2个。

<br>

还可以从一个module中导入所有export的函数。

	//math.js与上面相同
	//main.js
	import * as math from './math'
	math.add(1,2);

以上，不仅通过*把所有的导入进来，并且还给导入进来的module取了一个别名。

<br>

还可以从一个module中只导出一个指定函数。

	//math.js
	export default function doAllTheMath(x,y,z){
		return x + y + z;
	}

	//main.js
	import doAllTheMath from './math'
	doAllTheMath(1,2,3);

<br>
还可以既导出一个指定函数，同时导出其它函数。

	//math.js
	export function add(x,y){
		return x + y;
	}

	export default function doAllTheMath(x, y, z){
		return x + y + z;
	}

	//main.js
	import doAllTheMath, {add} from './math'
	doAllTheMath(1,2,3);
	add(1,2);

<br>

# ES6中的对象解构 #

<br>

来看一个无状态函数组件的写法。

	function register(props){
		return (
			<div>
				<span>Email</span>
				<input type='text' onChange={props.onChangeEmail} value={props.email} />
				......
			<div>
		)
	}

<br>

如果写成这样会不会更好呢？

<br>


	function register(props){
		var onChangeEmail = props.onChangeEmail;
		var email = props.email;
		return (
			<div>
				<span>Email</span>
				<input type='text' onChange={onChangeEmail} value={email} />
				......
			<div>
		)
	}

<br>

其实ES6为我们提供了一种结构对象的写法如下：

<br>

	functioin register(props){
		var {onChangeEmail, email} = props;

		return (
			<div>
				<span>Email</span>
				<input type='text' onChange={onChangeEmail} value={email} />
				......
		)
	}

<br>

再来看一个具体的例子。有关路由这块，以前我们这样写：

	var ReactRouter = require('react-router');
	var Route = ReactRouter.Route;
	var Link = ReactRouter.Link;
	var Router = ReactRouter.Router;

<br>

现在，在ES6中，我们可以解构ReactRouter这个对象。

	var {Route, Link, Router} = require('react-router');

<br>



> https://github.com/ReactjsProgram/React-Fundamentals

<br>

> fork到自己的github

<br>

> git clone https://github.com/darrenji/React-Fundamentals.git

<br>

> git checkout solution

<br>

> npm install

<br>



dd
d